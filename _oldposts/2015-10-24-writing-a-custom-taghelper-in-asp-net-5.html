---
layout: post
title: Writing a custom TagHelper in ASP.NET 5
date: 2015-10-24 21:10:34.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ASP.NET
- ASP.NET MVC
tags:
- asp.net
- asp.net vnext
- tag helpers
meta:
  _edit_last: '1'
  _publicize_twitter_user: "@WesleyCabus"
  _wpas_mess: 'Writing a custom TagHelper in #aspnet #vnext'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1512891862;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:527;}i:1;a:1:{s:2:"id";i:71;}i:2;a:1:{s:2:"id";i:231;}}}}
  _wpas_done_all: '1'
  _jetpack_dont_email_post_to_subs: '1'
  _wpas_skip_3127631: '1'
  _wpas_skip_12699179: '1'
author:
  login: Wesley
  email: wesley@gotsharp.be
  display_name: Wesley
  first_name: ''
  last_name: ''
---
<p>ASP.NET 5 brings some new features to MVC. One of these features is <em>TagHelpers</em>, which allow us to add new attributes to HTML tags (or create custom tags altogether) to add behavior to these tags. At this moment - beta8 - we receive the following TagHelpers out of the box:</p>
<p>- AnchorTagHelper: allows you to write <strong>&lt;a asp-controller="Home" asp-action="Index"&gt;Back to home&lt;/a&gt;</strong> instead of <strong>@Html.ActionLink("Back to home", "Index", "Home")<br />
</strong>- LabelTagHelper, InputTagHelper, TextAreaTagHelper, SelectTagHelper, etc.: instead of writing Razor like <strong>@Html.LabelFor(m =&gt; m.Property1, new { @class = "control-label col-md-2"})</strong>, you can use a syntax which is much cleaner: <strong>&lt;label asp-for="Property1" class="control-label col-md-2"&gt;&lt;/label&gt;<br />
</strong>- EnvironmentTagHelper: adds a new tag, &lt;environment&gt;, giving you the possibility to include &lt;link&gt; or &lt;script&gt; tags specific for Development or Production environments.<br />
- LinkTagHelper, ScriptTagHelper: adds attributes to &lt;link&gt; and &lt;script&gt; to allow the use of CDN's and fallback urls.</p>
<p>This list is incomplete, but you can <a href="https://github.com/aspnet/Mvc/tree/dev/src/Microsoft.AspNetCore.Mvc.TagHelpers" target="_blank">head over to GitHub</a> to see every available TagHelper class currently available.</p>
<p>You can also create your own TagHelper classes. I'll show you an example which enables you to do this:</p>
<pre class="lang:xhtml decode:true ">&lt;img asp-controller="Users" asp-action="ProfileImage" asp-route-id="@currentUserId" /&gt;</pre>
<p>That <em>img</em> tag would load a users profile image using the ProfileImage action method in a UsersController class: userful for retrieving a profile image from a blob container on Azure, for example.</p>
<p><!--more--></p>
<p>To create a custom TagHelper class, start by adding a dependency to the Microsoft.AspNet.Razor.Runtime NuGet package in project.json. You can add this dependency to the top list of global dependencies:</p>
<pre class="lang:js mark:18 decode:true">{
  "webroot": "wwwroot",
  "version": "1.0.0-*",

  "dependencies": {
    "Microsoft.AspNet.Diagnostics": "1.0.0-beta8",
    "Microsoft.AspNet.IISPlatformHandler": "1.0.0-beta8",
    "Microsoft.AspNet.Mvc": "6.0.0-beta8",
    "Microsoft.AspNet.Mvc.TagHelpers": "6.0.0-beta8",
    "Microsoft.AspNet.Server.Kestrel": "1.0.0-beta8",
    "Microsoft.AspNet.StaticFiles": "1.0.0-beta8",
    "Microsoft.AspNet.Tooling.Razor": "1.0.0-beta8",
    "Microsoft.Framework.Configuration.Json": "1.0.0-beta8",
    "Microsoft.Framework.Logging": "1.0.0-beta8",
    "Microsoft.Framework.Logging.Console": "1.0.0-beta8",
    "Microsoft.Framework.Logging.Debug": "1.0.0-beta8",
    "Microsoft.VisualStudio.Web.BrowserLink.Loader": "14.0.0-beta8",
    "Microsoft.AspNet.Razor.Runtime":  "4.0.0-beta8"
  },

...</pre>
<p>Next, add a new Class to your MVC project. Let's call this class <strong>ImageTagHelper</strong>, and let the class derive from the <strong>TagHelper</strong> class which lives in the <em>Microsoft.AspNet.Razor.Runtime.TagHelpers</em> namespace.</p>
<p>We're going to add three new attributes to the &lt;img&gt; tag:</p>
<ul>
<li>asp-controller: the MVC Controller</li>
<li>asp-action: the action method within the controller</li>
<li>asp-route-*: route values for the action method</li>
</ul>
<p>For each of these attributes, add a class level HtmlTargetElementAttribute:</p>
<pre class="lang:c# decode:true ">[HtmlTargetElement("img", Attributes = ActionAttributeName)]
[HtmlTargetElement("img", Attributes = ControllerAttributeName)]
[HtmlTargetElement("img", Attributes = RouteValuesPrefix + "*")]
public class ProfileImageTagHelper : TagHelper
{
    private const string ActionAttributeName = "asp-action";
    private const string ControllerAttributeName = "asp-controller";
    private const string RouteValuesPrefix = "asp-route-";
}</pre>
<p>I'm using constants here to define the attribute names: I can reuse these later when adding the properties which will receive the values of the HTML attributes. Let's add these properties now:</p>
<pre class="lang:c# decode:true ">[HtmlTargetElement("img", Attributes = ActionAttributeName)]
[HtmlTargetElement("img", Attributes = ControllerAttributeName)]
[HtmlTargetElement("img", Attributes = RouteValuesPrefix + "*")]
public class ProfileImageTagHelper : TagHelper
{
    private const string ActionAttributeName = "asp-action";
    private const string ControllerAttributeName = "asp-controller";
    private const string RouteValuesPrefix = "asp-route-";

    /// &lt;summary&gt;
    /// The name of the action method.
    /// &lt;/summary&gt;
    [HtmlAttributeName(ActionAttributeName)]
    public string Action { get; set; }

    /// &lt;summary&gt;
    /// The name of the controller.
    /// &lt;/summary&gt;
    [HtmlAttributeName(ControllerAttributeName)]
    public string Controller { get; set; }

    /// &lt;summary&gt;
    /// Additional parameters for the route.
    /// &lt;/summary&gt;
    [HtmlAttributeName(DictionaryAttributePrefix = RouteValuesPrefix)]
    public IDictionary&lt;string, string&gt; RouteValues { get; set; } =
        new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);
}</pre>
<p>By using a * at the end of the HtmlTargetElementAttribute, we can map multiple values into an IDictionary&lt;string, string&gt;. Think of this as a way to specify only one property to hold all data-* attributes.</p>
<p>It is now time to add the logic which will make this TagHelper work. Let's override the Process method:</p>
<pre class="lang:c# decode:true ">public override void Process(TagHelperContext context, TagHelperOutput output)
{
	if (context == null)
	{
		throw new ArgumentNullException(nameof(context));
	}

	if (output == null)
	{
		throw new ArgumentNullException(nameof(output));
	}

	// If "src" is already set, it means the user is attempting to use a normal img tag.
	if (output.Attributes.ContainsName("src"))
	{
		if (Action != null ||
			Controller != null ||
			RouteValues.Count != 0)
		{
			// User specified an src and one of the bound attributes; can't determine the src attribute.
			throw new InvalidOperationException(
				"Cannot override the src attribute of an &lt;img&gt; tag if the src attribute has a value.");
		}
	}
	else
	{
		// Convert from Dictionary&lt;string, string&gt; to Dictionary&lt;string, object&gt;.
		var routeValues = RouteValues.ToDictionary(
			kvp =&gt; kvp.Key,
			kvp =&gt; (object) kvp.Value,
			StringComparer.OrdinalIgnoreCase);

		var tagBuilder = new TagBuilder("img");
		tagBuilder.MergeAttribute("src", _urlHelper.Action(Action, Controller, routeValues));

		output.MergeAttributes(tagBuilder);
	}
}</pre>
<p>First of all, we check if the consumer of this custom TagHelper hasn't set a value for the <em>src</em> attribute, because then the &lt;img&gt; tag would just need to look at the original URI to retrieve the image. We will however show an error when the <em>src</em> attribute and one of our custom attributes has been set together.</p>
<p>If the developer is using our TagHelper without a <em>src</em> attribute, then we'll fill in the attribute ourselves using _urlHelper.Action(): that's the @Url.Action method you've been using in Razor all along. Of course, we still need to add that _urlHelper instance to our class and inject it. Here is the final version of our TagHelper class code:</p>
<pre class="lang:c# decode:true ">using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.AspNet.Mvc;
using Microsoft.AspNet.Mvc.Rendering;
using Microsoft.AspNet.Mvc.TagHelpers;
using Microsoft.AspNet.Razor.Runtime.TagHelpers;

namespace CustomTagHelperDemo.TagHelpers
{
    [HtmlTargetElement("img", Attributes = ActionAttributeName)]
    [HtmlTargetElement("img", Attributes = ControllerAttributeName)]
    [HtmlTargetElement("img", Attributes = RouteValuesPrefix + "*")]
    public class ProfileImageTagHelper : TagHelper
    {
        private readonly IUrlHelper _urlHelper;

        private const string ActionAttributeName = "asp-action";
        private const string ControllerAttributeName = "asp-controller";
        private const string RouteValuesPrefix = "asp-route-";
        
        public ProfileImageTagHelper(IUrlHelper urlHelper)
        {
            _urlHelper = urlHelper;
        }

        /// &lt;summary&gt;
        /// The name of the action method.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Must be &lt;c&gt;null&lt;/c&gt; if &lt;see cref="Route"/&gt; is non-&lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        [HtmlAttributeName(ActionAttributeName)]
        public string Action { get; set; }

        /// &lt;summary&gt;
        /// The name of the controller.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Must be &lt;c&gt;null&lt;/c&gt; if &lt;see cref="Route"/&gt; is non-&lt;c&gt;null&lt;/c&gt;.&lt;/remarks&gt;
        [HtmlAttributeName(ControllerAttributeName)]
        public string Controller { get; set; }

        /// &lt;summary&gt;
        /// Additional parameters for the route.
        /// &lt;/summary&gt;
        [HtmlAttributeName(DictionaryAttributePrefix = RouteValuesPrefix)]
        public IDictionary&lt;string, string&gt; RouteValues { get; set; } =
            new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase);

        /// &lt;summary&gt;
        /// Synchronously executes the &lt;see cref="T:Microsoft.AspNet.Razor.Runtime.TagHelpers.TagHelper"/&gt; with the given &lt;paramref name="context"/&gt; and
        ///             &lt;paramref name="output"/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name="context"&gt;Contains information associated with the current HTML tag.&lt;/param&gt;&lt;param name="output"&gt;A stateful HTML element used to generate an HTML tag.&lt;/param&gt;
        /// &lt;remarks&gt;Does nothing if user provides an &lt;c&gt;src&lt;/c&gt; attribute.&lt;/remarks&gt;
        /// &lt;exception cref="InvalidOperationException"&gt;
        /// Thrown if &lt;c&gt;src&lt;/c&gt; attribute is provided and &lt;see cref="Action"/&gt; or &lt;see cref="Controller"/&gt; are
        /// non-&lt;c&gt;null&lt;/c&gt; or if the user provided &lt;c&gt;asp-route-*&lt;/c&gt; attributes.
        /// &lt;/exception&gt;
        public override void Process(TagHelperContext context, TagHelperOutput output)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            if (output == null)
            {
                throw new ArgumentNullException(nameof(output));
            }

            // If "src" is already set, it means the user is attempting to use a normal anchor.
            if (output.Attributes.ContainsName("src"))
            {
                if (Action != null ||
                    Controller != null ||
                    RouteValues.Count != 0)
                {
                    // User specified an href and one of the bound attributes; can't determine the href attribute.
                    throw new InvalidOperationException(
                        "Cannot override the src attribute of an &lt;img&gt; tag if the src attribute has a value.");
                }
            }
            else
            {
                // Convert from Dictionary&lt;string, string&gt; to Dictionary&lt;string, object&gt;.
                var routeValues = RouteValues.ToDictionary(
                    kvp =&gt; kvp.Key,
                    kvp =&gt; (object) kvp.Value,
                    StringComparer.OrdinalIgnoreCase);

                var tagBuilder = new TagBuilder("img");
                tagBuilder.MergeAttribute("src", _urlHelper.Action(Action, Controller, routeValues));

                output.MergeAttributes(tagBuilder);
            }
        }
    }
}
</pre>
<p>But we're not done, yet. To be able to use custom TagHelper classes, you'll need to let Razor know about them.  Open the _ViewImports.cshtml file in the Views/Shared folder and add the following line:</p>
<pre class="lang:c# decode:true ">@addTagHelper "*, CustomTagHelperDemo"</pre>
<p>This line will tell Razor to load all TagHelper derived classes from the assembly CustomTagHelperDemo. You can also use the name of a specific TagHelper class instead of an asterisk. Also, don't forget to replace <em>CustomTagHelperDemo</em> with the name of your project or class library.</p>
<p>And now, you can open up a Razor file and tryout the new features you've added to the &lt;img&gt; tag:</p>
<pre class="lang:xhtml decode:true ">&lt;ul class="nav navbar-nav navbar-right"&gt;
	@if (User.Identity?.IsAuthenticated == true)
	{
		&lt;li&gt;
			&lt;img asp-controller="Users" asp-action="ProfileImage" asp-route-id="@User.FindFirst("sub").Value" /&gt;
			&lt;a asp-controller="Account" asp-action="Logoff"&gt;Sign out&lt;/a&gt;
		&lt;/li&gt;
	}
	else
	{
		&lt;li&gt;
			&lt;a asp-controller="Account" asp-action="Logon"&gt;Sign in&lt;/a&gt;
		&lt;/li&gt;
	}
&lt;/ul&gt;</pre>
<p>&nbsp;</p>
