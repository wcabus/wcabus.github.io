---
layout: post
title: Adding an MVC layer on top of a Web API backend
date: 2014-06-11 14:04:53.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ASP.NET
- ASP.NET MVC
- C#
- Web API
tags: []
meta:
  _edit_last: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1512903642;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:35;}i:1;a:1:{s:2:"id";i:501;}i:2;a:1:{s:2:"id";i:512;}}}}
  dsq_thread_id: '4914551802'
author:
  login: Wesley
  email: wesley@gotsharp.be
  display_name: Wesley
  first_name: ''
  last_name: ''
---
<p>It might just be me, but I don't seem to find a lot of examples out there showing how you can have an ASP.NET MVC website as a front end application using a Web API project as the backend service. Especially so when your front end is as basic as possible: I don't want to end up storing user data twice because I need to request OAuth tokens and store refresh tokens and so on...</p>
<p>If you want to dive into the code that I've produced, you can head straight to <a title="GitHub" href="https://github.com/wcabus/MvcOverWebApi" target="_blank">GitHub</a> and fetch it :)<br />
For more explanation, read on.</p>
<p><!--more--></p>
<p>OK, suppose I want to have a Web API on one server and a MVC front end on another server: how do we authenticate our users then, and how do we remember that authentication when accessing the Web API? Let's start by configuring the Web API part.</p>
<h3>Web API Configuration</h3>
<p>In the WebApiConfig class, I've set up two HostAuthenticationFilter's. You can specify as much of these filters as you want, each time providing another authentication type.</p>
<ul>
<li>The first one handles OAuth authentication requests, using a "Bearer" token. This means that in an HTTP request, you'll add an Authorization header with the value "Bearer &lt;auth token here&gt;"</li>
<li>The second one handles cookie authentication requests. Because I've used the DefaultAuthenticationTypes.ApplicationCookie value, I know that it will match the settings that I'm going to define in the Startup.Auth.cs file.</li>
</ul>
<p>For this to work, you also need to set up the correct authentication middleware. Adding these filters just tries to authenticate, but if no handler is found for the authentication type, nothing will happen. So let's go to Startup.Auth.cs and configure these handlers.</p>
<p>To handle cookie authentication, I've added the app.UseCookieAuthentication call. When generating a new Web API project, this line is also added but with the default CookieAuthenticationOptions. In this case, I want to have a bit more control over what actually happens, so we'll change the configuration slightly:</p>
<ul>
<li>AuthenticationType is set to DefaultAuthenticationTypes.ApplicationCookie. This should match the authentication type used in the HostAuthenticationFilter. Note: the default value is set in the constructor to CookieAuthenticationDefaults.AuthenticationType, which eventually is a string "Cookies".<br />
And if you really want to, you can specify your own name here. Just make sure to repeat the same name when you would otherwise use ApplicationCookie.</li>
<li><del>CookieHttpOnly is set to false, because I want to be able to authenticate using cookies from JavaScript as well.</del></li>
<li><em>Actually, Aymiee Lee pointed out that HttpOnly should NOT be false in this case. When performing AJAX requests in JavaScript, cookies will be sent along with those requests even if they are HTTP only. You only need to set this to false if you need to read cookies inside JavaScript, but that makes your website vulnerable to XSS attacks.</em></li>
<li>And finally, I've set a specific CookieName, so I know which name I need to use everywhere to read or write the cookie.</li>
</ul>
<p>The second handler (for bearer tokens) is also generated by default and I didn't change it, except the #if DEBUG line around AllowInsecureHttp. Never, ever allow insecure HTTP calls in production environments!</p>
<p>Just one more thing: in the web.config file, I've added a machineKey setting in the system.web section. This will need to be the same in our MVC site, otherwise the Web API layer can't read the cookie we've created in the MVC site.</p>
<h3>MVC Site Configuration</h3>
<p>Head over to web.config to see that I've indeed added the same machineKey in here. I've also added an appSetting called WebApiUri which holds the base uri where the API lives. If the Web API project runs on a different port on your machine, you'll need to change that port here.</p>
<p>Lastly, authentication has been configured to use Forms Authentication, using the /Account/SignIn action to authenticate our users.</p>
<h3>Registering</h3>
<p>First of all, if you want to test the application, you'll need to register yourself. So after running both the Web API and the MVC projects, head over to the MVC site and click on the Register link in the top right.</p>
<p><a href="https://wesleycabus.be/wp-content/uploads/2014/06/2014-06-11-12_44_35-Home-Page-My-ASP.NET-Application.png"><img class="aligncenter wp-image-131 size-full" src="{{ site.baseurl }}/assets/2014-06-11-12_44_35-Home-Page-My-ASP.NET-Application.png" alt="Register" width="952" height="133" /></a></p>
<p>Fill in the details and click the Register button. This might take a while, because Entity Framework needs to create the database first. Now, you can sign in using the just entered email address and password.</p>
<p>Registering is easy, because that can be done with a call to the Web API without having to be authenticated. If you go to the AccountController in the MVC project, check out the Register action method:</p>
<pre class="lang:c# decode:true">        // POST: Account/Register
        [HttpPost]
        public async Task&lt;ActionResult&gt; Register(RegisterModel model)
        {
            if (!ModelState.IsValid)
            {
                return View(model);
            }

            try
            {
                await WebApiService.Instance.PostAsync("/api/Account/Register", model);
                return View("Registered");
            }
            catch (ApiException ex)
            {
                //No 200 OK result, what went wrong?
                HandleBadRequest(ex);

                if (!ModelState.IsValid)
                {
                    return View(model);
                }

                throw;
            }
        }</pre>
<p>Using the WebApiService class (a simple wrapper for HttpClient), we post the RegisterModel to the Web API. After checking the data, it will then either return a BadRequest, or OK if the user profile has been created.</p>
<h3>Signing in</h3>
<p>After checking the ModelState, you can ask the Web API if it knows the given user credentials and of course if they are valid. To do this, you can make use of the "/Token" endpoint path, as configured in the Startup.Auth.cs file. Again, I've wrapped this in the WebApiService class:</p>
<pre class="lang:c# decode:true">        public async Task&lt;T&gt; AuthenticateAsync&lt;T&gt;(string userName, string password)
        {
            using (var client = new HttpClient())
            {
                var result = await client.PostAsync(BuildActionUri("/Token"), new FormUrlEncodedContent(new List&lt;KeyValuePair&lt;string, string&gt;&gt;
                {
                    new KeyValuePair&lt;string, string&gt;("grant_type", "password"),
                    new KeyValuePair&lt;string, string&gt;("userName", userName), 
                    new KeyValuePair&lt;string, string&gt;("password", password)
                }));

                string json = await result.Content.ReadAsStringAsync();
                if (result.IsSuccessStatusCode)
                {
                    return JsonConvert.DeserializeObject&lt;T&gt;(json);
                }

                throw new ApiException(result.StatusCode, json);
            }
        }</pre>
<p>The "/Token" endpoint expects form-encoded data instead of XML or JSON, that's why I had to use the FormUrlEncodedContent class to specify the data passed to the PostAsync method. The form body contains three parameters, of which the <em>grant_type</em> could need some explanation.<br />
There are different <em>grant_type</em>'s possible:</p>
<ul>
<li><em>password</em> - used to authenticate using a userName parameter and a password parameter, as I'm doing here.</li>
<li><em>authorization_code</em> - used to authenticate using a client id and secret.</li>
<li><em>client_credentials</em> - used when a client is requesting access to protected resources under its control (from within the Web API itself). Not usable in this case.</li>
<li><em>refresh_token</em> - used to refresh an access token if a refresh_token was given (most likely when requesting access with the authorization_code grant type)</li>
</ul>
<p>If you're wondering how this authentication is done, have a look inside the ApplicationOAuthProvider class in the Web API project. This class is also being generated when you create a new Web API project and specify that you want to have individual user accounts. The GrantResourceOwnerCredentials method is the one handling the authentication request.</p>
<p>After authenticating, you'll get a SignInResult containing these fields:</p>
<ul>
<li><em>access_token</em> - the magical identifier you can use in the Authorization header. This is your "Bearer" token.</li>
<li><em>token_type</em> - the type of token you've received. Currently, ASP.NET only returns "bearer".</li>
<li><em>expires_in</em> - number of seconds until this token expires</li>
<li><em>userName</em> - the user name as known in Web API</li>
<li><em>.issued</em> - the UTC date/time when this token has been granted</li>
<li><em>.expires</em> - the UTC date/time when this token expires</li>
</ul>
<p>With this information, we can now keep our user authenticated in both the MVC site and the Web API.<br />
For MVC, we use the FormsAuthentication.SetAuthCookie method to set the User.Identity and create the ASPXAUTH cookie. Note that I'm using the AccessToken as user name, you'll see why I'm doing that in just a minute.</p>
<p>But I also want to set another cookie, so I can authenticate in JavaScript. Remember that I've configured Web API to allow logging on using the ApplicationCookie? Now we're going to create it.</p>
<pre class="lang:c# decode:true">                //Create an AuthenticationTicket to generate a cookie used to authenticate against Web API.
                //But before we can do that, we need a ClaimsIdentity that can be authenticated in Web API.
                var claims = new[]
                {
                    new Claim(ClaimTypes.Name, result.UserName), //Name is the default name claim type, and UserName is the one known also in Web API.
                    new Claim(ClaimTypes.NameIdentifier, result.UserName) //If you want to use User.Identity.GetUserId in Web API, you need a NameIdentifier claim.
                };

                //Generate a new ClaimsIdentity, using the DefaultAuthenticationTypes.ApplicationCookie authenticationType.
                //This also matches what we've set up in Web API.
                var authTicket = new AuthenticationTicket(new ClaimsIdentity(claims, DefaultAuthenticationTypes.ApplicationCookie), new AuthenticationProperties
                {
                    ExpiresUtc = result.Expires,
                    IsPersistent = model.RememberMe,
                    IssuedUtc = result.Issued,
                    RedirectUri = redirectUrl
                });

                //And now it's time to generate the cookie data. This is using the same code that is being used by the CookieAuthenticationMiddleware class in OWIN.
                byte[] userData = DataSerializers.Ticket.Serialize(authTicket);
                
                //Protect this user data and add the extra properties. These need to be the same as in Web API!
                byte[] protectedData = MachineKey.Protect(userData, new[] { "Microsoft.Owin.Security.Cookies.CookieAuthenticationMiddleware", DefaultAuthenticationTypes.ApplicationCookie, "v1" });

                //base64-encode this data.
                string protectedText = TextEncodings.Base64Url.Encode(protectedData);
                
                //And now, we have the cookie.
                Response.SetCookie(new HttpCookie("YetAnotherTodo.WebApi.Auth")
                {
                    HttpOnly = true,
                    Expires = result.Expires.UtcDateTime,
                    Value = protectedText
                });</pre>
<p>The code above creates a new ClaimsIdentity with its authenticationType set to ApplicationCookie. This needs to match the HostAuthenticationFilter in Web API, or else it will not pick up this cookie to authenticate. That ClaimsIdentity is then being stored in an AuthenticationTicket because Web API will try to deserialize the cookie into this type. It doesn't stop here though, because before we can save the cookie, we need to convert the AuthenticationTicket into a base64-encoded string. So the ticket is being serialized, encrypted (and now you see why we need the same machine keys for MVC and Web API) and base64 encoded.<br />
Finally, we can create a new cookie with the same name as configured in Web API. <del>Again, HttpOnly is false to enable using this cookie in JavaScript.</del></p>
<h3>Accessing protected resources</h3>
<p>In MVC, head over to the TodoController and look at the TestApi action method first.</p>
<pre class="lang:c# decode:true">        public async Task&lt;ActionResult&gt; TestApi()
        {
            //Example call of the Web API from within MVC.
            //User.Identity.Name contains the bearer token if you've set it in the AccountController (using FormsAuthentication.SetAuthCookie)
            var result = await WebApiService.Instance.GetAsync&lt;ICollection&lt;TodoItem&gt;&gt;("/api/TodoItem", User.Identity.Name);
            return Json(result, JsonRequestBehavior.AllowGet);
        }</pre>
<p>When calling GetAsync or PostAsync on the WebApiService, you can add another parameter containing your authToken. Because we've specified this to be our user name when calling SetAuthCookie, this value is stored in User.Identity.Name in MVC. Inside the GetAsync method, I'm adding another header if this authToken has been set:</p>
<pre class="lang:c# mark:5-9 decode:true">        public async Task&lt;T&gt; GetAsync&lt;T&gt;(string action, string authToken = null)
        {
            using (var client = new HttpClient())
            {
                if (!authToken.IsNullOrWhiteSpace())
                {
                    //Add the authorization header
                    client.DefaultRequestHeaders.Authorization = AuthenticationHeaderValue.Parse("Bearer " + authToken);
                }
                
                var result = await client.GetAsync(BuildActionUri(action));
                
                string json = await result.Content.ReadAsStringAsync();
                if (result.IsSuccessStatusCode)
                {
                    return JsonConvert.DeserializeObject&lt;T&gt;(json);
                }

                throw new ApiException(result.StatusCode, json);
            }
        }</pre>
<p>But how do you access the Web API using JavaScript? Well, you could output the authToken in your view inside a script and pass a header object in your AJAX requests:</p>
<pre class="lang:js decode:true">$.ajax(apiSettings.baseUrl + '/api/TodoItem', {
    dataType: 'json',
    headers: {
        'authorization': 'Bearer ' + apiSettings.authToken
    }
});</pre>
<p>Or, if you're like me and want to do something special, you can use a cookie. In todoItems.js, I've changed the default ajax settings to include all cookies when making AJAX requests:</p>
<pre class="lang:js decode:true">$.ajaxSetup({
    xhrFields: {
        withCredentials: true // This setting passes cookies along the request, including our authentication cookie.
    }
});</pre>
<p>But when you start to use JavaScript to access an API that is hosted on another port (or domain), you'll immediately get errors when trying to access the API. You'll have to enable cross-origin shared resources (CORS) for this to work. In the WebApiConfig class, the line config.EnableCors enables CORS support for Web API (provided by the Microsoft.AspNet.WebApi.Cors NuGet package), but you also need to mark controllers or actions with the EnableCorsAttribute to actually allow accessing these resources.</p>
<p>In the TodoItemController in Web API, I've added this attribute to allow access from the MVC url. Again, if these projects are running on a different port, you'll need to change this. You can use * to allow any origin. The second parameter limits the headers (* for any), the third limits the operations (GET, POST, and again * to allow any). The last parameter is used so we can pass cookies in the AJAX request.</p>
<p>And that's it. Now you can use the ApplicationCookie in JavaScript to authenticate against Web API without having to explicitly add an auth token or a cookie name in your JavaScript code.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
