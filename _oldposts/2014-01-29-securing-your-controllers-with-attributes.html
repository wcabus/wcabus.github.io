---
layout: post
title: Securing your Controllers with Attribute's
date: 2014-01-29 20:19:57.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- ASP.NET MVC
tags: []
meta:
  _edit_last: '1'
  _wp_old_slug: securing-your-controllers-and-attributes
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1512873778;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:512;}i:1;a:1:{s:2:"id";i:71;}i:2;a:1:{s:2:"id";i:501;}}}}
author:
  login: Wesley
  email: wesley@gotsharp.be
  display_name: Wesley
  first_name: ''
  last_name: ''
---
<p>Today, while working on an ASP.NET MVC site, I wanted to do something special when securing a controller with the AuthorizeAttribute class:</p>
<pre>[Authorize(Roles = Role.Administrator.Or(Role.Management).ToString())]
public class SecretController : Controller {
...</pre>
<p>Initially, Administrator and Management where <em>static readonly</em> instances of the Role class. The Or extension method would combine their internal names together in a new Role instance. Finally, because of the overridden ToString method, the Roles property would receive the correct end result. However, when compiling, attributes must know their exact value. Read: constant value. So I couldn't assign Role instances at all.<br />
Also, having to end with a ToString() call didn't seem like a nice thing to do either.</p>
<p>So, back to the drawing board. This time, inside my Role class, I decided to declare my known roles as <em>const string</em>. But then I still can't use that Or extension method, because that would - again - result in a non-constant expression. I can, however, do this:</p>
<pre>[Roles(Role.Administrator, Role.Management)]
public class SecretController : Controller {
...</pre>
<p>Roles is a custom attribute, and is very simple indeed:</p>
<pre class="lang:c# decode:true">public class RolesAttribute : AuthorizeAttribute
{
   public RolesAttribute(params string[] roles)
   {
      if (roles == null)
         throw new ArgumentNullException("roles", "roles can not be a null reference.");

      Roles = string.Join(",", roles);
   }
}</pre>
<p>So now, you can specify as many roles as you like. And I'm quite happy with this.<br />
But <a title="@chrissie" href="http://twitter.com/chrissie" target="_blank">@chrissie</a> pointed me towardsÂ <a title="www.fluentsecurity.net" href="http://www.fluentsecurity.net" target="_blank">www.fluentsecurity.net</a>, which offers an entirely different approach. Also worth a look!</p>
